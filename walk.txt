get the triangle you're currently on

which is basically just getting your (x, y) then finding a triangle that overlaps and setting your z to the z
in the triangle at that x, y point

there could be issues with floating point precision if there are triangles that are really close together, but i
don't think that's a case we need to worry about


basically just find a triangle that has a close enough z to your z, or if you want, just get the highest triangle
below the player's current position, and just send them to that z and set their is_grounded to true.

or, instead, if you try and find a triangle that was close enough the player's z, but don't find one, just set
their is_grounded to false and let them fall.


on a player move, we transform the displacement that's on the xy-plane (it's on the x-y plane since we move with
WASD), so that it's parallel to the triangle that they're on.

we check if the x,y of the new position is on the same triangle. if it is, then we just do the move.

if it's not on the same triangle, we find the edge that the movement line intersected with.
and then we go to the triangle on the next edge. on this triangle, we do the same transform of the movement
vector and the same process. we do this until the needed displacement is 0.





the first method doesn't really take into account multiple walkable meshes, so we'd just be stuck on the same
mesh all the time.

- gather all the triangles that exist within an area that contains the displacement vector.
- do a test move on the current triangle (transform the vector to follow the triangle).
- if we end up outside, then just move up to where we intersect the edge.
- do the xy test on the gathered triangles to find the next closest triangle that is not the triangle that we were
  just on.
- go to step 2 until there is no more displacement left





b_1*v1 + b_2*(v_2-v_1) + b_3*(v_3-v_1) = (x, y) - b_1*v1

b1*v1.x + b2*(v2.x-v1.x) + b3*(v3.x-v1.x) = x


v0v1
v0v2
p

dot(p, normalize(v0v1)) > distance(v0v1)
= dot(p, normalize(v0v1) / distance(v0v1)) > 1.0f

u = dot(p, normalize(v0v1) / distance(v0v1))
v = dot(p, normalize(v0v2) / distance(v0v2))

if (u < 0.0f || u > 1.0f || v < 0.0f || v > 1.0f || (u + v) > 1.0f) {
   return false;
} else {
  return true;
}
