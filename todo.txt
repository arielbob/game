TODO: win32 platform layer threading support
TODO: mutexes
TODO: filesystem watching
- https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications
- https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstchangenotificationa
- WaitForMultipleObjects
- ReadDirectoryChangesW: https://gist.github.com/nickav/a57009d4fcc3b527ed0f5c9cf30618f8
  - https://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw_19.html
TODO: updating on asset file changes





TODO: actually test adding and removing folders...
- adding - DONE
- removing - DONE

TODO: Platform_Critical_Section delete all critical sections - NEVERMIND, it's fine
- we need to verify that none of the threads are waiting on it...
- that's annoying

TODO: end the file watchers at end of game loop - DONE
TODO: increment/decrement num_watchers when adding/deleting/folders - DONE





vvvvv LEFT OFF HERE vvvvv
TODO: create API for game to add and remove folders to watch
TODO: we need to mark entities as needing an update
- we could just have an array in a critical section with IDs in it, then every game loop, just go through
them and update them if they're in the array





have a thread that calls ReadDirectoryChanges
- then just call SleepEx(), so that it can run its completion routine when it gets changes
- the completion routine just pushes our own structure onto a queue that is protected by a mutex

- when we read, we just do the synchronization scheme that we did before, where we pause any of the queue updating
- then we read from the queue and update any entities based on the changes
- we unpause, then signal so that the queue updater can continue if necessary





main TODOs:
- circular buffer to store changes (this is basically a queue)
  - just store a first and end pointer
  - on adding, increment end pointer
  - on removing, just return whatever's at the first pointer, then increment the first pointer
    - shouldn't go past the end
- some type of synchronization scheme for protecting the buffer
- creating a thread that calls ReadDirectoryChanges
  - completion routine that pushes changes onto the queue in a thread-safe manner
- in the main update loop, read changes from the queue in a thread-safe manner
  - update entities accordingly




TODO: create a thread that calls ReadDirectoryChanges - DONE
TODO: get the completion routine to run on a file change - DONE

TODO: re-run the ReadDirectoryChanges once it runs once - DONE
- we can re-use the same OVERLAPPED structure, i think, since it's only being accessed by a single thread
  - (our file watching thread that we create)

TODO: interrupt the sleep thing when we exit, so that we don't just hang on program exit - DONE
- can't we just have a condition variable?
  - you wait on it, so you get put in the alertable state
  - except, now we can also just signal the condition variable when we want the thread to exit
- ACTUALLY, i think we were hanging for some other reason...
  - the thread automatically closes, since when the completion procedure runs on the altertable thread,
  the thread returns from the function that put it in the alertable state (SleepEx, in our case), and so the
  thread just finishes execution.
  - so you could just put the SleepEx call in a while (running) loop and when you want to end it, you can
  send something to the thread to put something on the async queue that sets running = false, the thread will
  be alerted, return from SleepEx, running = false, and end.
- ACTUALLY, we were hanging when pressing ESC to close, but not when clicking the X button on the window.
  - it's just that our WM_QUIT message handler was just returning, so we would just exit without waiting for any thread to finish
  - we want to close cleanly after WM_QUIT
  - now, WM_QUIT just sets is_running to false without returning and it hangs now like pressing ESC does.
    - we can still do the put SleepEx in a loop thing as mentioned above

TODO: implement platform critical sections - DONE
TODO: make thread-safe heap - DONE

Mutex m;
get_mutex(m);
release_mutex(m);

it's basically the same as a critical section..
- complete file_watcher_add_directory_routine()
- make the path string allocation in the passed in Win32_Directory_Watcher_Data struct
- we deallocate when we're done with it



TODO: could we really not just have had a CRITICAL_SECTION object in the win32_directory_watcher code?





TODO: adding folders to watcher

TODO: actually handle the different change notifications
- just put in the switch
- then, actually make it affect the game

TODO: watching multiple folders
- you need to just call multiple ReadDirectoryChanges on the same thread
- i think we just need multiple dir_watcher_datas, one for each ReadDirectoryChanges call
- and then a new struct that manages them all
- so we literally just do what we're doing now except just do it more
  - how do you do it from the main thread? like add directories?
  - you can use QueueUserAPC, with a new procedure like add_directory that just runs it on the file watching
  thread and adds a new directory!

TODO: error handling (bytesReturned + bytesTransferred)
TODO: close handles - need to do for multiple folders case
- CancelIO
- CloseHandle()
TODO: break from loop on WM_QUIT? instead of having loop run a single time after getting message





