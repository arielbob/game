TODO: win32 platform layer threading support
TODO: mutexes
TODO: filesystem watching
- https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications
- https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstchangenotificationa
- WaitForMultipleObjects
- ReadDirectoryChangesW: https://gist.github.com/nickav/a57009d4fcc3b527ed0f5c9cf30618f8
  - https://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw_19.html
TODO: updating on asset file changes





TODO: actually test adding and removing folders...
- adding - DONE
- removing - DONE

TODO: Platform_Critical_Section delete all critical sections - NEVERMIND, it's fine
- we need to verify that none of the threads are waiting on it...
- that's annoying

TODO: end the file watchers at end of game loop - DONE
TODO: increment/decrement num_watchers when adding/deleting/folders - DONE





TODO: check if folder is already being watched - DONE



vvvvv LEFT OFF HERE vvvvv
TODO: fix stack overrun error in visual studio when running - DONE
TODO: the End_Request needs to be allocated on the manager's heap, and NOT THE STACK!!!
TODO: GetFullPathNameW shouldn't be used with relative paths on other threads - maybe later; this wasn't the cause of the crash
- we should convert it on main thread before passing it to the watcher thread
TODO: fix end_request - DONE
TODO: we may want to convert the strings we get for paths to add to WCHAR strings and store them - DONE
- https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar
- just so it's easier to compare..
- or we just convert the filepaths we get from FILE_NOTIFY_INFORMATION to ascii strings...
  - i'm pretty sure we can just convert the filepaths we get there to "multibyte" strings
  - and since all our paths are ascii, we can just do string_equals and it'll be completely fine
  - TODO: honestly, it's better to just convert our ascii paths to unicode and use WCHAR
    - it's more annoying and more prone to error converting from unicode to multibyte
    - https://stackoverflow.com/questions/748965/what-is-a-multibyte-character-set
    - multibyte seems to refer to legacy variable-length encodings, like specific codepages
      - https://learn.microsoft.com/en-us/cpp/c-runtime-library/unicode-the-wide-character-set?view=msvc-170
        - "Only one locale can be represented at a time in multibyte encoding"
      - https://learn.microsoft.com/en-us/cpp/c-runtime-library/single-byte-and-multibyte-character-sets?view=msvc-170&redirectedfrom=MSDN
        - "A multibyte character set can consist of both 1-byte and 2-byte characters."
        - so, multibyte character doesn't seem to refer to utf-8, since utf-8 uses 1-4 code units (of size 1 byte each) to represent code points





TODO: create API for game to add and remove folders to watch - DONE
- TODO: adding - DONE
- TODO: removing - DONE
- TODO: pass in function pointer to handle the file changes - DONE
- TODO: need to create platform-independent types of file change types - DONE
  - like PLATFORM_FILE_MODIFIED or whatever
TODO: verify that we're aligning the buffer to DWORD - DONE

TODO: it's listening recursively.. but we don't want that? the false i set isn't for recursive i think..
- actually, i don't think it is listening recursively; it's just that the change propagated up to the folder
  - and the folder is what's getting modified
  - we get a modified for the file past the root layer, but we don't get the file renamed event, since i think
  it's just the folder that is seen as modified

TODO: watch directories when we add assets
- TODO: meshes - DONE

TODO: fix bugs with mesh directory watching
- crash when exiting - DONE



TODO: update mesh when file updated
- TODO: handle rename event - DONE
- TODO: do the actual update - DONE
- probably need to delete everything, then reload it
- or maybe load it first, and then delete the old stuff
  - just in case load fails

TODO: fix stack allocator getting corrupted after get_mesh_by_path after two file changes - DONE
TODO: do the "keep old mesh until new one is guaranteed added" thing in update_meshes_from_queue - DONE
TODO: test the updating again when a file is in use - DONE, it works
- could we just keep the file handle? idk.. well, we do, but our flags are all SHARE_*
- it's that, i think, blender still has it open?





TODO: if we delete meshes, then we need to also delete the watcher for it..
- we probably need to keep a counter on the watcher_data
- because we don't have duplicate watchers for the same paths
- update refresh_mesh() if we do this
- TODO: we actually probably want to be able to register multiple watchers on the same thing - DONE
  - we could just have IDs on the watchers
  - then return it, then when we want to cancel, just send in that ID
  - on the assets side, we would need to do the check for duplication ourselves
    - just have a list and look for it..
    - store the watcher id in the asset's struct



vvvvv LEFT OFF HERE vvvvv
TODO: fix the assert firing with weird t's when loading in the monkey animation



- TODO: textures
- TODO: animations
- TODO: levels - i don't think we need this..? levels are only really ever edited in our program

TODO: we may want to step through the refreshing code
- verify that the old data is getting unloaded in GL code
- maybe verify that the meshes are also getting properly deleted from asset manager



TODO: replace duplicate code and test TABLE_DELETE macro

TODO: actually update the stuff when the file changes
- TODO: meshes
- TODO: levels
- TODO: textures
- TODO: animations

TODO: do logging for the updates we get

TODO: thread-local temp regions
- can use GetCurrentThreadId()
- so we can use begin_region() without having to use locks



TODO: we need to mark entities as needing an update
- we could just have an array in a critical section with IDs in it, then every game loop, just go through
them and update them if they're in the array





have a thread that calls ReadDirectoryChanges
- then just call SleepEx(), so that it can run its completion routine when it gets changes
- the completion routine just pushes our own structure onto a queue that is protected by a mutex

- when we read, we just do the synchronization scheme that we did before, where we pause any of the queue updating
- then we read from the queue and update any entities based on the changes
- we unpause, then signal so that the queue updater can continue if necessary





main TODOs:
- circular buffer to store changes (this is basically a queue)
  - just store a first and end pointer
  - on adding, increment end pointer
  - on removing, just return whatever's at the first pointer, then increment the first pointer
    - shouldn't go past the end
- some type of synchronization scheme for protecting the buffer
- creating a thread that calls ReadDirectoryChanges
  - completion routine that pushes changes onto the queue in a thread-safe manner
- in the main update loop, read changes from the queue in a thread-safe manner
  - update entities accordingly




TODO: create a thread that calls ReadDirectoryChanges - DONE
TODO: get the completion routine to run on a file change - DONE

TODO: re-run the ReadDirectoryChanges once it runs once - DONE
- we can re-use the same OVERLAPPED structure, i think, since it's only being accessed by a single thread
  - (our file watching thread that we create)

TODO: interrupt the sleep thing when we exit, so that we don't just hang on program exit - DONE
- can't we just have a condition variable?
  - you wait on it, so you get put in the alertable state
  - except, now we can also just signal the condition variable when we want the thread to exit
- ACTUALLY, i think we were hanging for some other reason...
  - the thread automatically closes, since when the completion procedure runs on the altertable thread,
  the thread returns from the function that put it in the alertable state (SleepEx, in our case), and so the
  thread just finishes execution.
  - so you could just put the SleepEx call in a while (running) loop and when you want to end it, you can
  send something to the thread to put something on the async queue that sets running = false, the thread will
  be alerted, return from SleepEx, running = false, and end.
- ACTUALLY, we were hanging when pressing ESC to close, but not when clicking the X button on the window.
  - it's just that our WM_QUIT message handler was just returning, so we would just exit without waiting for any thread to finish
  - we want to close cleanly after WM_QUIT
  - now, WM_QUIT just sets is_running to false without returning and it hangs now like pressing ESC does.
    - we can still do the put SleepEx in a loop thing as mentioned above

TODO: implement platform critical sections - DONE
TODO: make thread-safe heap - DONE

Mutex m;
get_mutex(m);
release_mutex(m);

it's basically the same as a critical section..
- complete file_watcher_add_directory_routine()
- make the path string allocation in the passed in Win32_Directory_Watcher_Data struct
- we deallocate when we're done with it



TODO: could we really not just have had a CRITICAL_SECTION object in the win32_directory_watcher code?





TODO: adding folders to watcher

TODO: actually handle the different change notifications
- just put in the switch
- then, actually make it affect the game

TODO: watching multiple folders
- you need to just call multiple ReadDirectoryChanges on the same thread
- i think we just need multiple dir_watcher_datas, one for each ReadDirectoryChanges call
- and then a new struct that manages them all
- so we literally just do what we're doing now except just do it more
  - how do you do it from the main thread? like add directories?
  - you can use QueueUserAPC, with a new procedure like add_directory that just runs it on the file watching
  thread and adds a new directory!

TODO: error handling (bytesReturned + bytesTransferred)
TODO: close handles - need to do for multiple folders case
- CancelIO
- CloseHandle()
TODO: break from loop on WM_QUIT? instead of having loop run a single time after getting message





