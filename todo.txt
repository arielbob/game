TODO: win32 platform layer threading support
TODO: mutexes
TODO: filesystem watching
- https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications
- https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstchangenotificationa
- WaitForMultipleObjects
- ReadDirectoryChangesW: https://gist.github.com/nickav/a57009d4fcc3b527ed0f5c9cf30618f8
  - https://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw_19.html
TODO: updating on asset file changes



have a thread that calls ReadDirectoryChanges
- then just call SleepEx(), so that it can run its completion routine when it gets changes
- the completion routine just pushes our own structure onto a queue that is protected by a mutex

- when we read, we just do the synchronization scheme that we did before, where we pause any of the queue updating
- then we read from the queue and update any entities based on the changes
- we unpause, then signal so that the queue updater can continue if necessary





main TODOs:
- circular buffer to store changes (this is basically a queue)
  - just store a first and end pointer
  - on adding, increment end pointer
  - on removing, just return whatever's at the first pointer, then increment the first pointer
    - shouldn't go past the end
- some type of synchronization scheme for protecting the buffer
- creating a thread that calls ReadDirectoryChanges
  - completion routine that pushes changes onto the queue in a thread-safe manner
- in the main update loop, read changes from the queue in a thread-safe manner
  - update entities accordingly




TODO: create a thread that calls ReadDirectoryChanges - DONE
TODO: get the completion routine to run on a file change - DONE

TODO: re-run the ReadDirectoryChanges once it runs once - DONE
- we can re-use the same OVERLAPPED structure, i think, since it's only being accessed by a single thread
  - (our file watching thread that we create)

TODO: interrupt the sleep thing when we exit, so that we don't just hang on program exit - DONE
- can't we just have a condition variable?
  - you wait on it, so you get put in the alertable state
  - except, now we can also just signal the condition variable when we want the thread to exit
- ACTUALLY, i think we were hanging for some other reason...
  - the thread automatically closes, since when the completion procedure runs on the altertable thread,
  the thread returns from the function that put it in the alertable state (SleepEx, in our case), and so the
  thread just finishes execution.
  - so you could just put the SleepEx call in a while (running) loop and when you want to end it, you can
  send something to the thread to put something on the async queue that sets running = false, the thread will
  be alerted, return from SleepEx, running = false, and end.
- ACTUALLY, we were hanging when pressing ESC to close, but not when clicking the X button on the window.
  - it's just that our WM_QUIT message handler was just returning, so we would just exit without waiting for any thread to finish
  - we want to close cleanly after WM_QUIT
  - now, WM_QUIT just sets is_running to false without returning and it hangs now like pressing ESC does.
    - we can still do the put SleepEx in a loop thing as mentioned above

TODO: implement platform critical sections - DONE

TODO: make thread-safe heap

Mutex m;
get_mutex(m);
release_mutex(m);

it's basically the same as a critical section..






TODO: actually handle the different change notifications
- just put in the switch
- then, actually make it affect the game

TODO: watching multiple folders
- you need to just call multiple ReadDirectoryChanges on the same thread
- i think we just need multiple dir_watcher_datas, one for each ReadDirectoryChanges call
- and then a new struct that manages them all
- so we literally just do what we're doing now except just do it more
  - how do you do it from the main thread? like add directories?
  - you can use QueueUserAPC, with a new procedure like add_directory that just runs it on the file watching
  thread and adds a new directory!

TODO: error handling (bytesReturned + bytesTransferred)
TODO: close handles - need to do for multiple folders case
- CancelIO
- CloseHandle()
TODO: break from loop on WM_QUIT? instead of having loop run a single time after getting message





